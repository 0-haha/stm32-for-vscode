
/*
 * Set of functions for creating a makefile based on STM32 makefile info and the Src, Inc and Lib folders
 * Created by Jort Band - Bureau Moeilijke Dingen
*/
import _ from 'lodash';
import vscode from 'vscode';
import fs from 'fs';
import path from 'path';
import getMakefileInfo from './MakefileInfo';
import getFileList from './ListFiles';
import { makefileName } from './Definitions';
/**
 * @description Combines the information from the Makefile and the FileList
 * @param {object} makefileInfo
 * @param {object} fileList
 */
export function bundleInfo(makefileInfo, fileList) {
  const bundledInfo = {};

  // Bundling info which both the makeFile and the Filelist have
  combineArraysIntoObject(makefileInfo.cSources, fileList.cFiles, 'cSources', bundledInfo);
  combineArraysIntoObject(makefileInfo.cxxSources, fileList.cxxFiles, 'cxxSources', bundledInfo);
  combineArraysIntoObject(makefileInfo.asmSources, fileList.asmFiles, 'asmSources', bundledInfo);
  combineArraysIntoObject(makefileInfo.cIncludes, fileList.cIncludes, 'cIncludes', bundledInfo);
  combineArraysIntoObject(makefileInfo.cxxIncludes, null, 'cxxIncludes', bundledInfo);
  combineArraysIntoObject(makefileInfo.asIncludes, null, 'asIncludes', bundledInfo);

  // now assign makelist values
  _.set(bundledInfo, 'target', makefileInfo.target);
  _.set(bundledInfo, 'cpu', makefileInfo.cpu);
  _.set(bundledInfo, 'fpu', makefileInfo.fpu);
  _.set(bundledInfo, 'floatAbi', makefileInfo.floatAbi);
  _.set(bundledInfo, 'mcu', makefileInfo.mcu);
  _.set(bundledInfo, 'ldscript', makefileInfo.ldscript);
  _.set(bundledInfo, 'cDefs', makefileInfo.cDefs);
  _.set(bundledInfo, 'cxxDefs', makefileInfo.cxxDefs);
  _.set(bundledInfo, 'asDefs', makefileInfo.asDefs);
  return bundledInfo;
}
/**
 * @description Check if the programm is a c++ or c program and automatically converts.
 * @param {object} info combined info of the makefile and filelist
 */
export function checkAndConvertCpp(info) {
  const newInfo = _.cloneDeep(info);
  if (!(_.indexOf(info.cxxSources, 'main.cpp') === -1) || !(_.indexOf(info.cxxSources, 'Main.cpp') === -1)) {
    // then it has a main.cpp file
    // check for a main.c file
    let indMain = _.indexOf(info.cSources, 'main.c');
    if (indMain === -1) { indMain = _.indexOf(info.cSources, 'Main.c'); }
    if (indMain >= 0) {
      // remove the main. file.
      newInfo.cSources.splice(indMain, 1);
    }
  } else if (!_.isEmpty(info.cxxSources)) {
    vscode.window.showWarningMessage('You have several cxx/cpp files, however no main.cpp file. Will ignore these files for now');
    // should clear the current files
    newInfo.cxxSources = [];
  }
  return newInfo;
}
/**
 *
 * @param {string[]} arr1
 * @param {string[]} arr2
 * @param {string} key
 * @param {object} obj
 */
export function combineArraysIntoObject(arr1, arr2, key, obj) {
  // GUARD: against empty or null arrays.
  if (!arr2 || !_.isArray(arr2)) {
    if (arr1 && _.isArray(arr1)) {
      _.set(obj, key, arr1.sort());
      return obj;
    }
    _.set(obj, key, []);
    return obj;
  }
  if (!arr1 || !_.isArray(arr1)) {
    _.set(obj, key, arr2);
    return obj;
  }
  let totalArray = arr1.concat(arr2);
  totalArray = _.uniq(totalArray).sort();
  _.set(obj, key, totalArray);
  return obj;
}

/**
 * @description creates a makefile readable list.
 * @param {string[]} arr
 */
export function createStringList(arr) {
  // guard against singular entries.
  if (!_.isArray(arr)) {
    if (_.isString(arr)) return arr;
    return '';
  }
  let output = '';
  _.map(arr, (entry, ind) => {
    output += `${entry}`;
    if (ind < arr.length - 1) {
      output += ' \\';
    }
    output += '\r\n';
  });

  return output;
}

export function convertTemplate(makeInfo) {
  // NOTE: check for the correct info needs to be given beforehand
  const makeFile = `##########################################################################################################################
# File automatically-generated by STM32forVSCode: [projectgenerator] version: [3.0.0] date: [Fri Jan 25 18:00:27 CET 2019]
##########################################################################################################################

# ------------------------------------------------
# Generic Makefile (based on gcc)
#
# ChangeLog :
#	2017-02-10 - Several enhancements + project update mode
#   2015-07-22 - first version
# ------------------------------------------------

######################################
# target
######################################
TARGET = ${makeInfo.target}


######################################
# building variables
######################################
# debug build?
DEBUG = 1
# optimization
OPT = -Og


#######################################
# paths
#######################################
# Build path
BUILD_DIR = build

######################################
# source
######################################
# C sources
C_SOURCES =  ${'\\'}
${createStringList(makeInfo.cSources)}

CPP_SOURCES = ${'\\'}
${createStringList(makeInfo.cppSources)}

# ASM sources
ASM_SOURCES =  ${'\\'}
${createStringList(makeInfo.asmSources)}


#######################################
# binaries
#######################################
PREFIX = arm-none-eabi-
# The gcc compiler bin path can be either defined in make command via GCC_PATH variable (> make GCC_PATH=xxx)
# either it can be added to the PATH environment variable.
ifdef GCC_PATH
CPP = $(GCC_PATH)/$(PREFIX)g++
CC = $(GCC_PATH)/$(PREFIX)gcc
AS = $(GCC_PATH)/$(PREFIX)gcc -x assembler-with-cpp
CP = $(GCC_PATH)/$(PREFIX)objcopy
SZ = $(GCC_PATH)/$(PREFIX)size
else
CPP = $(PREFIX)g++
CC = $(PREFIX)gcc
AS = $(PREFIX)gcc -x assembler-with-cpp
CP = $(PREFIX)objcopy
SZ = $(PREFIX)size
endif
HEX = $(CP) -O ihex
BIN = $(CP) -O binary -S
	
#######################################
# CFLAGS
#######################################
# cpu
CPU = ${makeInfo.cpu}

# fpu
FPU = ${makeInfo.fpu}

# float-abi
FLOAT-ABI = ${makeInfo.floatAbi}

# mcu
MCU = ${makeInfo.mcu}

# macros for gcc
# AS defines
AS_DEFS = 

# C defines
C_DEFS =  ${'\\'}
${createStringList(makeInfo.cDefs)}


# AS includes
AS_INCLUDES = ${'\\'}
${createStringList(makeInfo.asmIncludes)}

# C includes
C_INCLUDES =  ${'\\'}
${createStringList(makeInfo.cIncludes)}


# compile gcc flags
ASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections

CFLAGS = $(MCU) $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections

ifeq ($(DEBUG), 1)
CFLAGS += -g -gdwarf-2
endif


# Generate dependency information
CFLAGS += -MMD -MP -MF"$(@:%.o=%.d)"


#######################################
# LDFLAGS
#######################################
# link script
LDSCRIPT = ${makeInfo.ldscript}

# libraries
LIBS = -lc -lm -lnosys 
LIBDIR = 
LDFLAGS = $(MCU) -specs=nosys.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections

# default action: build all
all: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin


#######################################
# build the application
#######################################
# list of cpp program objects
OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(CPP_SOURCES:.cpp=.o)))
vpath %.cpp $(sort $(dir $(CPP_SOURCES)))
# list of C objects
OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))
vpath %.c $(sort $(dir $(C_SOURCES)))
# list of ASM program objects
OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))
vpath %.s $(sort $(dir $(ASM_SOURCES)))

$(BUILD_DIR)/%.o: %.cpp Makefile | $(BUILD_DIR) 
	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(<:.cpp=.lst)) $< -o $@

$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) 
	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(<:.c=.lst)) $< -o $@

$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR)
	$(AS) -c $(CFLAGS) $< -o $@

$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile
	$(CC) $(OBJECTS) $(LDFLAGS) -o $@
	$(SZ) $@

$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR)
	$(HEX) $< $@
	
$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR)
	$(BIN) $< $@	
	
$(BUILD_DIR):
	mkdir $@		

#######################################
# clean up
#######################################
clean:
	-rm -fR $(BUILD_DIR)
	
#######################################
# dependencies
#######################################
-include $(wildcard $(BUILD_DIR)/*.d)

# *** EOF ***`;

  return makeFile;
}
/**
 *
 * @param {object} makefileInfo
 * @param {object} fileList
 */
export async function getMakefile(makefileInfo, fileList) {
  let totalInfo = bundleInfo(makefileInfo, fileList);
  totalInfo = checkAndConvertCpp(totalInfo);
  const makeFile = convertTemplate(totalInfo);
  return makeFile;
}

async function getCurrentMakefile(makeFilePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(makeFilePath, { encoding: 'utf8' }, (err, currentMakefile) => {
      if (err) {
        reject(err);
        return;
      }
      resolve(currentMakefile);
    });
  });
}

async function writeMakefile(makeFilePath, makefile) {
  return new Promise((resolve, reject) => {
    fs.writeFile(makeFilePath, makefile, { encoding: 'utf8' }, (err) => {
      if (err) {
        vscode.window.showErrorMessage('Something went wrong with writing to the new makefile', err);
        reject(err);
        return;
      }
      resolve();
    });
  });
}

export default async function createMakefile(location) {
  return new Promise((resolve, reject) => {
    let makefileInfo = null;
    let fileInfo = null;
    const makefileInfoPromise = getMakefileInfo(location);
    const fileInfoPromise = getFileList(location);
    Promise.all([makefileInfoPromise, fileInfoPromise]).then(async (values) => {
      [makefileInfo, fileInfo] = values;
      // after this the new makefile should be created if it has changed
      const newMakefile = getMakefile(makefileInfo, fileInfo);
      let currentMakeFile = null;
      const makeFilePath = path.resolve(location, makefileName);
      try {
        currentMakeFile = await getCurrentMakefile(makeFilePath);
      } catch (err) {
        // do nothing.
      }
      // check if there is a current makefile and if they are the same if not write new one.
      if (currentMakeFile !== newMakefile || !currentMakeFile) {
        try {
          await writeMakefile(makeFilePath, newMakefile);
        } catch (err) {
          reject(err);
        }
      }
    }).catch((err) => {
      vscode.window.showErrorMessage('Something went wrong with scanning the directory and opening the makefile', err);
      reject(err);
    });
  });
}
